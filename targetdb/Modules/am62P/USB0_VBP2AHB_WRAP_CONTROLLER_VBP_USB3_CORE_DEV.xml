<module name="USB0_VBP2AHB_WRAP_CONTROLLER_VBP_USB3_CORE_DEV" acronym="" XML_version="1.0" HW_revision="n/a" description="">
	<register id="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DCFG" acronym="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DCFG" offset="0x0" width="32" description="Device Configuration Register. 

This register configures the controller in Device mode after power-on or after certain control commands or enumeration. Do not make changes to this register after initial programming.">
		<bitfield id="IGNSTRMPP" width="1" begin="23" end="23" resetval="0x0" description="IgnoreStreamPP This bit only affects stream-capable bulk endpoints.  When this bit is set to '0' and the controller receives a Data Packet with the Packet Pending [PP] bit set to 0 for OUT endpoints, or it receives an ACK with the NumP field set to 0 and PP set to 0 for IN endpoints, the controller attempts to search for another stream [CStream] to initiate to the host. However, there are two situations where this behavior is not optimal:  - When the host is setting PP=0 even though it has not finished the stream, or  - When the endpoint on the device is configured with one transfer resource and therefore does not have any other streams to initiate to the host. When this bit is set to '1', the controller ignores the Packet Pending bit for the purposes of stream selection and does not search for another stream when it receives DP[PP=0] or ACK[NumP=0, PP=0]. This can enhance the performance when the device system bus bandwidth is low or the host responds to the controller's ERDY transmission very quickly." range="23" rwaccess="R/W"/> 
		<bitfield id="LPMCAP" width="1" begin="22" end="22" resetval="0x0" description="LPM Capable   The application uses this bit to control the LPM capabilities of the DWC_usb3 controller. If the controller operates as a non-LPM-capable device, it cannot respond to LPM transactions.  - 1'b0: LPM capability is not enabled.  - 1'b1: LPM capability is enabled." range="22" rwaccess="R/W"/> 
		<bitfield id="NUMP" width="5" begin="21" end="17" resetval="0x4" description="Number of Receive Buffers.   This bit indicates the number of receive buffers to be reported in the ACK TP.  The DWC_usb3 controller uses this field for non-control endpoints if GRXTHRCFG.UsbRxPktCntSel is set to '0'. The application can program this value based on RxFIFO size, buffer sizes programmed in descriptors, and system latency.  For an OUT endpoint, this field controls the number of receive buffers reported in the NumP field of the ACK TP transmitted by the controller.  Note: This bit is used in host mode when Debug Capability is enabled." range="21 - 17" rwaccess="R/W"/> 
		<bitfield id="INTRNUM" width="5" begin="16" end="12" resetval="0x0" description="Interrupt number   Indicates interrupt/EventQ number on which non-endpoint-specific device-related interrupts [see DEVT] are generated." range="16 - 12" rwaccess="R/W"/> 
		<bitfield id="DEVADDR" width="7" begin="9" end="3" resetval="0x0" description="Device Address.  The application must perform the following:  - Program this field after every SetAddress request.  - Reset this field to zero after USB reset." range="9 - 3" rwaccess="R/W"/> 
		<bitfield id="DEVSPD" width="3" begin="2" end="0" resetval="0x0" description="Device Speed.   Indicates the speed at which the application requires the controller to connect, or the maximum speed the application can support.   However, the actual bus speed is determined only after the chirp sequence is completed, and is based on the speed of the USB host to which the controller is connected.  - 3'b100: SuperSpeed [USB 3.0 PHY clock is 125 MHz or 250 MHz]  - 3'b000: High-speed [USB 2.0 PHY clock is 30 MHz or 60 MHz]  - 3'b001: Full-speed [USB 2.0 PHY clock is 30 MHz or 60 MHz]" range="2 - 0" rwaccess="R/W"/>
	</register>
	<register id="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DCTL" acronym="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DCTL" offset="0x4" width="32" description="Device Control Register

Note:

When Hibernation is not enabled using GCTL.GblHibernationEn field,
 - you can write any value to CSS, CRS, L1HibernationEn, and KeepConnect fields
 - L1HibernationEn, and KeepConnect fields always return 0 when read in this hibernation-disabled state">
		<bitfield id="RUN_STOP" width="1" begin="31" end="31" resetval="0x0" description="Run/Stop  The software writes 1 to this bit to start the device controller operation.  To stop the device controller operation, the software must remove any active transfers and write 0 to this bit. When the controller is stopped, it sets the DSTS.DevCtrlHlt bit when the controller is idle and the lower layer finishes the disconnect process.  The Run/Stop bit must be used in following cases as specified:  - After power-on reset and CSR initialization, the software must write 1 to this bit to start the device controller. The controller does not signal connect to the host until this bit is set.  - The software uses this bit to control the device controller to perform a soft disconnect. When the software writes 0 to this bit, the host does not see that the device is connected. The device controller stays in the disconnected state until the software writes 1 to this bit. The minimum duration of keeping this bit cleared is specified in the Note below. If the software attempts a connect after the soft disconnect or detects a disconnect event, it must set DCTL[8:5] to 5 before reasserting the Run/Stop bit.  - When the USB or Link is in a lower power state and the Two Power Rails configuration is selected, software writes 0 to this bit to indicate that it is going to turn off the Core Power Rail. After the software turns on the Core Power Rail again and re-initializes the device controller, it must set this bit to start the device controller. For more details, see Low Power Operation section of the Databook. Note: The following is the minimum duration under various conditions for which the soft disconnect [SftDiscon] bit must be set for the USB host to detect a device disconnect:  30ms:  - For SuperSpeed, when the device state is Suspended, Idle, Transmit, or Receive.  10ms:  - For high-speed, when the device state is Suspended, Idle, or not Idle/Suspended [performing transactions]  - For full-speed/low-speed, when the device state is Suspended, Idle, or not Idle/Supended [performing transactions] To accommodate clock jitter, it is recommended that the application add extra delay to the specified minimum duration." range="31" rwaccess="R/W"/> 
		<bitfield id="CSFTRST" width="1" begin="30" end="30" resetval="0x0" description="Core Soft Reset  Resets the all clock domains as follows:  - This bit clears the interrupts and all the CSRs except GSTS, GSNPSID, GGPIO, GUID, GUSB2PHYCFGn registers, GUSB3PIPECTLn registers, DCFG, DCTL, DEVTEN, and DSTS registers.  - All module state machines [except the SoC Bus Target Unit] are reset to the IDLE state, and all the TxFIFOs and the RxFIFO are flushed.  - Any transactions on the SoC bus Initiator are terminated as soon as possible, after gracefully completing the last data phase of a SoC bus transfer. Any transactions on the USB are terminated immediately. The application can write this bit at any time to reset the controller. This is a self-clearing bit. the controller clears this bit after all necessary logic is reset in the controller, which may take several clocks depending on the current state of the controller. Once this bit is cleared, the software must wait at least 3 PHY clocks before accessing the PHY domain [synchronization delay]. Typically, software reset is used during software development and also when you dynamically change the PHY selection bits in the USB configuration registers listed above. When you change the PHY, the corresponding clock for the PHY is selected and used in the PHY domain. Once a new clock is selected, the PHY domain must be reset for proper operation.  Note: Programming this field with random data causes side effect . Bit Bash register testing is not recommended." range="30" rwaccess="R/W1TS"/> 
		<bitfield id="RESERVED" width="1" begin="29" end="29" resetval="0x0" description="Reserved1" range="29" rwaccess="N/A"/> 
		<bitfield id="HIRDTHRES" width="5" begin="28" end="24" resetval="0x0" description="HIRD Threshold [HIRD_Thres]  The controller asserts output signals utmi_l1_suspend_n and utmi_sleep_n [see LPM Interface Signals table in the Databook] on the basis of this signal:  The controller asserts utmi_l1_suspend_n to put the PHY into Deep Low-Power mode in L1 when both of the following are true:  - HIRD value is greater than or equal to the value in DCTL.HIRD_Thres[3:0]  - HIRD_Thres[4] is set to 1'b1. The controller asserts utmi_sleep_n on L1 when one of the following is true:  - If the HIRD value is less than HIRD_Thres[3:0] or  - HIRD_Thres[4] is set to 1'b0. Note: This field must be set to '0' during SuperSpeed mode of operation." range="28 - 24" rwaccess="R/W"/> 
		<bitfield id="LPM_NYET_THRES" width="4" begin="23" end="20" resetval="0x15" description="LPM NYET Threshold  When LPM Errata is enabled:  Bits [23:20]: LPM NYET Response Threshold [LPM_NYET_thres]  Handshake response to LPM token specified by device application. Response depends on DCFG.LPMCap.  - DCFG.LPMCap is 1'b0 - The controller always responds with Timeout [that is, no response].  - DCFG.LPMCap is 1'b1 - The controller responds with an ACK on successful LPM transaction, which requires that all of the following are satisfied:  - There are no PID or CRC5 errors in both the EXT token and the LPM token [if not true, inactivity results in a timeout ERROR].   - No data is pending in the TxFIFO and RxFIFO is empty [else NYET].  - The BESL value in the LPM token is less than or equal to LPM_NYET_thres[3:0]" range="23 - 20" rwaccess="R/W"/> 
		<bitfield id="KEEPCONNECT" width="1" begin="19" end="19" resetval="0x0" description="Keep Connect   When '1', this bit enables the save and restore programming model by preventing the controller from disconnecting from the host when DCTL.RunStop is set to '0'.   It also enables the Hibernation Request Event to be generated when the link goes to U3 or L2.  The device controller disconnects from the host when DCTL.RunStop is set to '0'.   This bit indicates whether to preserve this behavior ['0'], or if the controller must not disconnect when RunStop is set to 0 ['1'].  This bit also prevents the LTSSM from automatically going to U0/L0 when the host requests resume from U3/L2.  Note: If Hibernation is disabled, that is, GCTL[1].GblHibernationEn = 0, this bit is tied to zero." range="19" rwaccess="W"/> 
		<bitfield id="L1HIBERNATIONEN" width="1" begin="18" end="18" resetval="0x0" description="L1HibernationEn   When this bit is set along with KeepConnect, the device controller generates a Hibernation Request Event if L1 is enabled and the HIRD value in the LPM token is larger than the threshold programmed in DCTL.HIRD_Thres.   The controller does not exit the LPM L1 state until software writes Recovery into the DCTL.ULStChngReq field.   This prevents corner cases where the device is entering hibernation at the same time the host is attempting to exit L1.  Note: If Hibernation is disabled, that is, GCTL[1].GblHibernationEn = 0, this bit is tied to zero." range="18" rwaccess="W"/> 
		<bitfield id="CRS" width="1" begin="17" end="17" resetval="0x0" description="Controller Restore State [CRS]  This command is similar to the USBCMD.CRS bit in host mode and initiates the restore process. When software sets this bit to '1', the controller immediately sets DSTS.RSS to '1'. When the controller has finished the restore process, it sets DSTS.RSS to '0'.  Note: When read, this field always returns '0'." range="17" rwaccess="R/W"/> 
		<bitfield id="CSS" width="1" begin="16" end="16" resetval="0x0" description="Controller Save State [CSS]  This command is similar to the USBCMD.CSS bit in host mode and initiates the save process. When software sets this bit to '1', the controller immediately sets DSTS.SSS to '1'. When the controller has finished the save process, it sets DSTS.SSS to '0'.  Note: When read, this field always returns '0'." range="16" rwaccess="R/W"/> 
		<bitfield id="INITU2ENA" width="1" begin="12" end="12" resetval="0x0" description="Initiate U2 Enable  - 1'b0: May not initiate U2 [default]  - 1'b1: May initiate U2  On USB reset, hardware clears this bit to 0. Software sets this bit after receiving SetFeature[U2_ENABLE], and clears this bit when ClearFeature[U2_ENABLE] is received.  If DCTL[11] [AcceptU2Ena] is 0, the link immediately exits U2 state." range="12" rwaccess="R/W"/> 
		<bitfield id="ACCEPTU2ENA" width="1" begin="11" end="11" resetval="0x0" description="Accept U2 Enable   - 1'b0: Reject U2 except when Force_LinkPM_Accept bit is set [default]  - 1'b1: Controller accepts transition to U2 state if nothing is pending on the application side.  On USB reset, hardware clears this bit to 0. Software sets this bit after receiving a SetConfiguration command." range="11" rwaccess="R/W"/> 
		<bitfield id="INITU1ENA" width="1" begin="10" end="10" resetval="0x0" description="Initiate U1 Enable   - 1'b0: May not initiate U1 [default].   - 1'b1: May initiate U1.  On USB reset, hardware clears this bit to 0. Software sets this bit after receiving SetFeature[U1_ENABLE], and clears this bit when ClearFeature[U1_ENABLE] is received.   If DCTL[9] [AcceptU1Ena] is 0, the link immediately exits U1 state." range="10" rwaccess="R/W"/> 
		<bitfield id="ACCEPTU1ENA" width="1" begin="9" end="9" resetval="0x0" description="Accept U1 Enable  - 1'b0: Controller rejects U1 except when Force_LinkPM_Accept bit is set [default]  - 1'b1: Controller accepts transition to U1 state if nothing is pending on the application side.  On USB reset, hardware clears this bit to 0. Software sets this bit after receiving a SetConfiguration command." range="9" rwaccess="R/W"/> 
		<bitfield id="ULSTCHNGREQ" width="4" begin="8" end="5" resetval="0x0" description="ULSTCHNGREQ  Software writes this field to issue a USB/Link state change request. A change in this field indicates a new request to the controller.   If software wants to issue the same request back-to-back, it must write a 0 to this field between the two requests. The result of the state change request is reflected in the USB/Link State in DSTS. These bits are self-cleared on the MAC Layer exiting suspended state.  If software is updating other fields of the DCTL register and not intending to force any link state change, then it must write a 0 to this field.  SS Compliance mode is normally entered and controlled by the remote link partner. Refer to the USB 3.0 specification.   Alternatively, you can force the local link directly into compliance mode, by resetting the SS link with the RUN/STOP bit set to zero.   If you then write '10' to the USB/Link State Change field and '1' to RUN/STOP, the link goes to compliance mode.   Once you are in compliance, you may alternately write zero and '10' to this field to advance the compliance pattern.  In SS mode:  - Value Requested Link State Transition/Action   - 0  No Action  - 4  SS.Disabled  - 5  Rx.Detect  - 6  SS.Inactive  - 8  U3 exit request  - 10  Compliance  - Others:  Reserved In HS/FS/LS mode:  - ValueRequested USB state transition  - 8  Remote wakeup request  - Others: Reserved The Remote wakeup request must be issued 2us after the device goes into suspend state [DSTS[21:18] is 3 - refer to Table Fields for Register: DSTS].  Note: After coming out of hibernation, software must write 8 [Recovery] into this field to confirm exit from the suspended state." range="8 - 5" rwaccess="W"/> 
		<bitfield id="TSTCTL" width="4" begin="4" end="1" resetval="0x0" description="Test Control   - 4'b000: Test mode disabled  - 4'b001: Test_J mode  - 4'b010: Test_K mode  - 4'b011: Test_SE0_NAK mode  - 4'b100: Test_Packet mode  - 4'b101: Test_Force_Enable  - Others: Reserved" range="4 - 1" rwaccess="R/W"/>
	</register>
	<register id="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DEVTEN" acronym="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DEVTEN" offset="0x8" width="32" description="Device Event Enable Register

This register controls the generation of device-specific events (see Event Buffer Content for Device-Specific Events (DEVT) section). If an enable bit is set to 0, the event will not be generated.">
		<bitfield id="ECCERREN" width="1" begin="16" end="16" resetval="0x0" description="ECC Error Enable.  If this bit is set to 1, the controller reports an ECC error to the software when an uncorrectable ECC occurs internally." range="16" rwaccess="R"/> 
		<bitfield id="L1WKUPEVTEN" width="1" begin="14" end="14" resetval="0x0" description="L1 Resume Detected Event Enable.  Note: If GUCTL1[DEV_DECOUPLE_L1L2_EVT] is enabled, then this bit is for L1 Resume Detected Event Enable." range="14" rwaccess="R/W"/> 
		<bitfield id="VENDEVTSTRCVDEN" width="1" begin="12" end="12" resetval="0x0" description="Vendor Device Test LMP Received Event [VndrDevTstRcvedEn]" range="12" rwaccess="R/W"/> 
		<bitfield id="ERRTICERREVTEN" width="1" begin="9" end="9" resetval="0x0" description="Erratic Error Event Enable" range="9" rwaccess="R/W"/> 
		<bitfield id="L1SUSPEN" width="1" begin="8" end="8" resetval="0x0" description="L1 Suspend Event Enable  Note: Only if GUCTL1[DEV_DECOUPLE_L1L2_EVT] is enabled, this bit is for L1 Suspend Event Enable." range="8" rwaccess="R/W"/> 
		<bitfield id="SOFTEVTEN" width="1" begin="7" end="7" resetval="0x0" description="Start of [u]frame" range="7" rwaccess="R/W"/> 
		<bitfield id="U3L2L1SUSPEN" width="1" begin="6" end="6" resetval="0x0" description="U3/L2 or U3/L2L1 Suspend Event Enable.   Note:  - If GUCTL1[DEV_DECOUPLE_L1L2_EVT] is enabled, then this bit is for U3/L2 Suspend Event Enable.  - If GUCTL1[DEV_DECOUPLE_L1L2_EVT] is not enabled, then this bit is for U3/L2L1 Suspend Event Enable." range="6" rwaccess="R/W"/> 
		<bitfield id="HIBERNATIONREQEVTEN" width="1" begin="5" end="5" resetval="0x0" description="This bit enables/disables the generation of the Hibernation Request Event." range="5" rwaccess="R/W"/> 
		<bitfield id="WKUPEVTEN" width="1" begin="4" end="4" resetval="0x0" description="U3/L2 or U3/L2L1 Resume Detected Event Enable.  Note:  - If GUCTL1[DEV_DECOUPLE_L1L2_EVT] is enabled, then this bit is for U3/L2 Resume Detected Event Enable.  - If GUCTL1[DEV_DECOUPLE_L1L2_EVT] is not enabled, then this bit is for U3/L2L1 Resume Detected Event Enable." range="4" rwaccess="R/W"/> 
		<bitfield id="ULSTCNGEN" width="1" begin="3" end="3" resetval="0x0" description="USB/Link State Change Event Enable" range="3" rwaccess="R/W"/> 
		<bitfield id="CONNECTDONEEVTEN" width="1" begin="2" end="2" resetval="0x0" description="Connection Done Enable" range="2" rwaccess="R/W"/> 
		<bitfield id="USBRSTEVTEN" width="1" begin="1" end="1" resetval="0x0" description="USB Reset Enable" range="1" rwaccess="R/W"/> 
		<bitfield id="DISSCONNEVTEN" width="1" begin="0" end="0" resetval="0x0" description="Disconnect Detected Event Enable" range="0" rwaccess="R/W"/>
	</register>
	<register id="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DSTS" acronym="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DSTS" offset="0xC" width="32" description="Device Status Register

This register indicates the status of the device controller with respect to USB-related events.

Note:

When Hibernation is not enabled, RSS and SSS fields always return 0 when read.">
		<bitfield id="DCNRD" width="1" begin="29" end="29" resetval="0x0" description="Device Controller Not Ready   The bit indicates that the controller is in the process of completing the state transitions after exiting from hibernation.   To complete the state transitions, it takes 256 bus clock cycles from the time DCTL[31].Run/Stop is set. During hibernation, if the UTMI/ULPI PHY is in suspended state, then the 256-bus clock cycle delay starts after the PHY exited suspended state. Software must set DCTL[31].Run/Stop to '1' and wait for this bit to be de-asserted to zero before processing DSTS.USBLnkSt.   This bit is valid only when DWC_USB3_EN_PWROPT is set to 2 and GCTL[1].GblHibernationEn =1." range="29" rwaccess="R"/> 
		<bitfield id="SRE" width="1" begin="28" end="28" resetval="0x0" description="Save Restore Error. Currently not supported." range="28" rwaccess="R/W1TC"/> 
		<bitfield id="RSS" width="1" begin="25" end="25" resetval="0x0" description="RSS Restore State Status     This bit is similar to the USBSTS.RSS in host mode.  When the controller finishes the restore process, it completes the command by setting DSTS.RSS to '0'." range="25" rwaccess="R"/> 
		<bitfield id="SSS" width="1" begin="24" end="24" resetval="0x0" description="SSS Save State Status    This bit is similar to the USBSTS.SSS in host mode.  When the controller has finished the save process, it completes the command by setting DSTS.SSS to '0'." range="24" rwaccess="R"/> 
		<bitfield id="COREIDLE" width="1" begin="23" end="23" resetval="0x0" description="Core Idle     The bit indicates that the controller finished transferring all RxFIFO data to system memory, writing out all completed descriptors, and all Event Counts are zero.  Note: While testing for Reset values, mask out the read value. This bit represents the changing state of the controller and does not hold a static value." range="23" rwaccess="R"/> 
		<bitfield id="DEVCTRLHLT" width="1" begin="22" end="22" resetval="0x1" description="Device Controller Halted   This bit is set to 0 when the Run/Stop bit in the DCTL register is set to 1.  The controller sets this bit to 1 when, after SW sets Run/Stop to 0, the controller is idle and the lower layer finishes the disconnect process.  When Halted=1, the controller does not generate Device events.   Note:   - The controller does not set this bit to 1 if GEVNTCOUNTn has some valid value. Software needs to acknowledge the events that are generated [by writing to GEVNTCOUNTn] while it is waiting for this bit to be set to 1.  - When Interrupt Moderation is enabled, there could be delay in raising the interrupt line when the event count is non-zero. Software should read the GEVNTCOUNT register directly and acknowledge them." range="22" rwaccess="R"/> 
		<bitfield id="USBLNKST" width="4" begin="21" end="18" resetval="0x4" description="USBLNKST.  USB/Link State  In SS mode: LTSSM State  - 4'h0: U0  - 4'h1: U1  - 4'h2: U2  - 4'h3: U3  - 4'h4: SS_DIS  - 4'h5: RX_DET  - 4'h6: SS_INACT  - 4'h7: POLL  - 4'h8: RECOV  - 4'h9: HRESET  - 4'ha: CMPLY  - 4'hb: LPBK  - 4'hf: Resume/Reset In HS/FS/LS mode:  - 4'h0: On state  - 4'h2: Sleep [L1] state  - 4'h3: Suspend [L2] state  - 4'h4: Disconnected state [Default state]  - 4'h5: Early Suspend state [valid only when Hibernation is disabled, GCTL[1].GblHibernationEn = 0]  - 4'he: Reset [valid only when Hibernation is enabled, GCTL[1].GblHibernationEn = 1]  - 4'hf: Resume [valid only when Hibernation is enabled, GCTL[1].GblHibernationEn = 1] The link state Resume/Reset indicates that the controller received a resume or USB reset request from the host while the link was in hibernation. Software must write '8' [Recovery] to the DCTL.ULStChngReq field to acknowledge the resume/reset request.   When Hibernation is enabled, GCTL[1].GblHibernationEn = 1, this field USBLnkSt is valid only when DCTL[31].Run/Stop set to '1' and DSTS[29].DCNRD = 0.  The Early Suspend link state is an early indication of device suspend in HS/FS. The link state changes to Early Suspend after detecting bus idle for 3ms.  - In HS operation, this is an indication that the USB bus [that is, LineState] has been in idle [SE0] for 3ms. However, it does not confirm whether the next process is Suspend or Reset. The device checks the bus again after pull up enable delay and if the line state indicates Suspend [full speed J], then the device waits for an additional time [~3ms] to indicate the actual Suspend state.  - In FS operation, this is an indication that the USB bus [that is, LineState] has been in idle [J] for 3ms. The device waits for an additional time [~3ms of Idle] to indicate the actual Suspend state." range="21 - 18" rwaccess="R"/> 
		<bitfield id="RXFIFOEMPTY" width="1" begin="17" end="17" resetval="0x1" description="RxFIFO Empty." range="17" rwaccess="R"/> 
		<bitfield id="SOFFN" width="14" begin="16" end="3" resetval="0x0" description="Frame/Microframe Number of the Received SOF.   When the controller is operating at SuperSpeed,   - [16:3] indicates the uframe/ITP number When the controller is operating at high-speed,   - [16:6] indicates the frame number  - [5:3] indicates the microframe number When the controller is operating at full-speed,   - [16:14] is not used. Software can ignore these 3 bits  - [13:3] indicates the frame number Note: After power-on reset, the controller generates the microframe number internally for every 125us if the USB host has not issued SOF/ITP yet. During P3 state, the duration of SOFFN is based on the suspend_clk frequency." range="16 - 3" rwaccess="R"/> 
		<bitfield id="CONNECTSPD" width="3" begin="2" end="0" resetval="0x4" description="Connected Speed [ConnectSpd]  Indicates the speed at which the DWC_usb3 controller has come up after speed detection through a chirp sequence.  - 3'b100: SuperSpeed [PHY clock is running at 125 or 250 MHz]  - 3'b000: High-speed [PHY clock is running at 30 or 60 MHz]  - 3'b001: Full-speed [PHY clock is running at 30 or 60 MHz] Low-speed is not supported for devices using a UTMI+ PHY." range="2 - 0" rwaccess="R"/>
	</register>
	<register id="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DGCMDPAR" acronym="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DGCMDPAR" offset="0x10" width="32" description="Device Generic Command Parameter Register

This register indicates the device command parameter. This must be programmed before or along with the device command. The available device commands are listed in DGCMD register.">
		<bitfield id="PARAMETER" width="32" begin="31" end="0" resetval="0x0" description="PARAMETER" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DGCMD" acronym="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DGCMD" offset="0x14" width="32" description="Device Generic Command Register

This register enables software to program the controller using a single generic command interface to send link management packets and notifications. This register contains command, control, and status fields relevant to the current generic command, while the DGCMDPAR register provides the command parameter.">
		<bitfield id="CMDSTATUS" width="4" begin="15" end="12" resetval="0x0" description="Command Status   - 1: CmdErr:  Indicates that the device controller encountered an error while processing the command.  - 0: Indicates command success" range="15 - 12" rwaccess="R"/> 
		<bitfield id="CMDACT" width="1" begin="10" end="10" resetval="0x0" description="Command Active  The software sets this bit to 1 to enable the device controller to execute the generic command.  The device controller sets this bit to 0 after executing the command." range="10" rwaccess="R/W1TS"/> 
		<bitfield id="CMDIOC" width="1" begin="8" end="8" resetval="0x0" description="Command Interrupt on Complete  When this bit is set, the device controller issues a Generic Command Completion event after executing the command.   Note that this interrupt is mapped to DCFG.IntrNum.  Note: This field must not set to '1' if the DCTL.RunStop field is '0'." range="8" rwaccess="R/W"/> 
		<bitfield id="CMDTYP" width="8" begin="7" end="0" resetval="0x0" description="CMDTYP    Generic Command Type   Specifies the type of generic command the software driver is requesting the controller to perform.  - 02h: Set Periodic Parameters  - 04h: Set Scratchpad Buffer Array Address Lo  - 05h: Set Scratchpad Buffer Array Address Hi  - 07h: Transmit Device Notification  - 09h: Selected FIFO Flush  - 0Ah: All FIFO Flush  - 0Ch: Set Endpoint NRDY  - 10h: Run SoC Bus LoopBack Test  - 11h: Restart After Disconnect All other values are reserved." range="7 - 0" rwaccess="R/W"/>
	</register>
	<register id="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DALEPENA" acronym="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DALEPENA" offset="0x20" width="32" description="Device Active USB Endpoint Enable Register. 

This register indicates whether a USB endpoint is active in a given configuration or interface.">
		<bitfield id="USBACTEP" width="32" begin="31" end="0" resetval="0x0" description="USBACTEP     USB Active Endpoints [USBActEP]  This field indicates if a USB endpoint is active in the current configuration and interface. It applies to USB IN endpoints 0.15 and OUT endpoints 0.15, with one bit for each of the 32 possible endpoints. Even numbers are for USB OUT endpoints, and odd numbers are for USB IN endpoints, as follows:  - Bit[0]: USB EP0-OUT  - Bit[1]: USB EP0-IN  - Bit[2]: USB EP1-OUT  - Bit[3]: USB EP1-IN The entity programming this register must set bits 0 and 1 because they enable control endpoints that map to physical endpoints [resources] after USBReset.  Hardware clears these bits for all endpoints [other than EP0-OUT and EP0-IN] after detecting a USB reset event. After receiving SetConfiguration and SetInterface requests, the application must program endpoint registers accordingly and set these bits.  For more information, see Flexible Endpoint Mapping section in the Databook." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_Rsvd" acronym="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_Rsvd" offset="0x24" width="32" description="Reserved">
		
	</register>
	<register id="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DEPCMDPAR2" acronym="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DEPCMDPAR2" offset="0x100" width="32" description="Device Physical Endpoint-n Command Parameter 2 Register (DEPCMDPAR2n)

This register indicates the physical endpoint command Parameter 2. It must be programmed before issuing the command.">
		<bitfield id="PARAMETER" width="32" begin="31" end="0" resetval="0x0" description="PARAMETER" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DEPCMDPAR1" acronym="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DEPCMDPAR1" offset="0x104" width="32" description="Device Physical Endpoint-n Command Parameter 1 Register (DEPCMDPAR1n)">
		<bitfield id="PARAMETER" width="32" begin="31" end="0" resetval="0x0" description="PARAMETER" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DEPCMDPAR0" acronym="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DEPCMDPAR0" offset="0x108" width="32" description="Device Physical Endpoint-n Command Parameter 0 Register (DEPCMDPAR0n)">
		<bitfield id="PARAMETER" width="32" begin="31" end="0" resetval="0x0" description="PARAMETER" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DEPCMD" acronym="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DEPCMD" offset="0x10C" width="32" description="Device Physical Endpoint-n Command Register

This register enables software to issue physical endpoint-specific commands. This register contains command, control, and status fields relevant to the current generic command, while the DEPCMDPAR[2:0]n registers provide command parameters and return status information.

Several fields (including Command Type) are write-only, so their read values are undefined. After power-on, prior to issuing the first endpoint command, the read value of this register is undefined. In particular, the CmdAct bit may be set after power-on. In this case, it is safe to issue an endpoint command.">
		<bitfield id="COMMANDPARAM" width="16" begin="31" end="16" resetval="0x0" description="Command Parameters or Event Parameters  Command Parameters [CommandParam], when this register is written:  For Start Transfer command:  -  [31:16]: StreamID. The USB StreamID assigned to this transfer For Start Transfer command applied to an isochronous endpoint  - [31:16]: StartMicroFramNum: Indicates the [micro]frame number to which the first TRB applies.  For Update Transfer, End Transfer, and Start New Configuration commands  - [22:16]: Transfer Resource Index [XferRscIdx]. The hardware-assigned transfer resource index for the transfer, which was returned in response to the Start Transfer command. The application software-assigned transfer resource index for a Start New Configuration command. Event Parameters [EventParam], when this register is read. Refer to bits [31:16] in Table Device Endpoint-n Events: DEPEVT." range="31 - 16" rwaccess="R/W"/> 
		<bitfield id="CMDSTATUS" width="4" begin="15" end="12" resetval="0x0" description="Command Completion Status [CmdStatus]  Additional information about the completion of this command is available in this field. The information is in the same format as bits 15:12 of the Endpoint Command Complete event, see Device Endpoint-n Events: DEPEVT table in the Programming Guide." range="15 - 12" rwaccess="R/W"/> 
		<bitfield id="HIPRI_FORCERM" width="1" begin="11" end="11" resetval="0x0" description="HighPriority/ForceRM [HiPri_ForceRM]   - HighPriority: Only valid for Start Transfer command  - ForceRM: Only valid for End Transfer command  - ClearPendIN: Only valid for Clear Stall command . Software sets this bit to clear any pending IN transaction [on that endpoint] stuck at the lower layers when a Clear Stall command is issued." range="11" rwaccess="R/W"/> 
		<bitfield id="CMDACT" width="1" begin="10" end="10" resetval="0x0" description="Command Active [CmdAct]  Software sets this bit to 1 to enable the device endpoint controller to execute the generic command.  The device controller sets this bit to 0 when the CmdStatus field is valid and the endpoint is ready to accept another command. This does not imply that all the effects of the previously-issued command have taken place." range="10" rwaccess="R/W"/> 
		<bitfield id="CMDIOC" width="1" begin="8" end="8" resetval="0x0" description="CMDIOC  Command Interrupt on Complete [CmdIOC]  When this bit is set, the device controller issues a generic Endpoint Command Complete event after executing the command.   Note that this interrupt is mapped to DEPCFG.IntrNum.  When the DEPCFG command is executed, the command interrupt on completion goes to the interrupt pointed by the DEPCFG.IntrNum in the current command.  Note: This field must not set to 1 if the DCTL.RunStop field is 0." range="8" rwaccess="R/W"/> 
		<bitfield id="CMDTYP" width="4" begin="3" end="0" resetval="0x0" description="Command Type  Specifies the type of command the software driver is requesting the controller to perform.  - 00h: Reserved  - 01h: Set Endpoint Configuration - -64 or 96-bit Parameter  - 02h: Set Endpoint Transfer Resource Configuration - 32-bit Parameter  - 03h: Get Endpoint State - No Parameter Needed  - 04h: Set Stall - No Parameter Needed  - 05h: Clear Stall [see Set Stall] - No Parameter Needed  - 06h: Start Transfer - 64-bit Parameter  - 07h: Update Transfer - No Parameter Needed  - 08h: End Transfer - No Parameter Needed  - 09h: Start New Configuration - No Parameter Needed" range="3 - 0" rwaccess="R/W"/>
	</register>
	<register id="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DEV_IMOD" acronym="VBP2AHB_WRAP__CONTROLLER_VBP__USB3_CORE_DEV_DEV_IMOD" offset="0x300" width="32" description="Device Interrupt Moderation Register (DEV_IMOD)

This register controls the Interrupt Moderation feature that allows the device software to throttle the interrupt rate.

Key Functions:
 - Interrupt Moderation is enabled only when the IMOD Interval is programmed to a non-zero value.
 - Interrupt is asserted whenever the IMOD (down) counter is 0, EVNT_HANDLER_BUSY is 0, and there are pending events (that is, event count is non-zero)
 - GEVNTCOUNT[EVNT_HANDLER_BUSY] is set by hardware when interrupt is asserted, and cleared by software when interrupt processing is completed.
 - The Interrupt line is de-asserted after the first write to the event count.
 - IMOD counter is loaded with IMOD interval whenever the Interrupt line is de-asserted.">
		<bitfield id="DEVICE_IMODC" width="16" begin="31" end="16" resetval="0x0" description="Interrupt Moderation Down Counter  Loaded with the DEVICE_IMODI value, whenever the hardware interrupt[n] line is de-asserted from the asserted state, counts down to 0, and stops.   The interrupt[n] is signaled whenever this counter is 0, EVNT_HANDLER_BUSY is 0, and there are pending events [that is, event count is non-zero].   This counter may be directly written by software at any time to alter the interrupt rate." range="31 - 16" rwaccess="R/W"/> 
		<bitfield id="DEVICE_IMODI" width="16" begin="15" end="0" resetval="0x0" description="Moderation Interval [DEVICE_IMODI]  This field holds the minimum inter-interrupt interval between events. The interval is specified in terms of 250ns increments.   A value of 0 disables the interrupt throttling logic and interrupts are generated immediately if event count becomes non-zero.  In scaledown simulation mode, 4 ram clocks are used to time 250ns." range="15 - 0" rwaccess="R/W"/>
	</register>
</module>