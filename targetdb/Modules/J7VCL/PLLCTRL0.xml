<module name="PLLCTRL0" acronym="" XML_version="1.0" HW_revision="n/a" description="">
  <register id="PID" acronym="PID" offset="0x0" width="32" description="Return to the . Peripheral identification register">
    <bitfield id="SCHEME" width="2" begin="31" end="30" resetval="0x1" description="Peripheral identification register scheme" range="" rwaccess="R"/>
    <bitfield id="BU" width="2" begin="29" end="28" resetval="0x0" description="Business Unit" range="" rwaccess="R"/>
    <bitfield id="FUNC" width="12" begin="27" end="16" resetval="0x481" description="Module ID" range="" rwaccess="R"/>
    <bitfield id="RTL" width="5" begin="15" end="11" resetval="0xB" description="RTL revision.Will vary depending on release" range="" rwaccess="R"/>
    <bitfield id="MAJOR" width="3" begin="10" end="8" resetval="0x4" description="Major revision" range="" rwaccess="R"/>
    <bitfield id="CUSTOM" width="2" begin="7" end="6" resetval="0x0" description="Custom" range="" rwaccess="R"/>
    <bitfield id="MINOR" width="6" begin="5" end="0" resetval="0x0" description="Minor revision" range="" rwaccess="R"/>
  </register>
  <register id="PLLCTL" acronym="PLLCTL" offset="0x100" width="32" description="Return to the . PLL control register">
    <bitfield id="RSVD2" width="22" begin="31" end="10" resetval="0x0" description="Reserved" range="" rwaccess="RW"/>
    <bitfield id="EXCLKSRC" width="1" begin="9" end="9" resetval="0x0" description="Selects between using bypass clock or an external clock source. 0=bypass clock 1=external clock source" range="" rwaccess="RW"/>
    <bitfield id="CLKMODE" width="1" begin="8" end="8" resetval="0xX" description="Reference Clock Selection. 1 = clkin_pi is the reference clock 0 = oscin_pi is the reference clock This bit is only applicable when d_clkmodesrc_pi = 1. It is otherwise don't care." range="" rwaccess="RW"/>
    <bitfield id="PLLSELB" width="1" begin="7" end="7" resetval="0x0" description="Selects PLL A versus PLL B. 1 = PLL B is selected. PLL A is put in power down (pll_a_pwrdn_po = 1) 0 = PLL A is selected. PLL B is put in power down. (pll_b_pwrdn_po = 1)" range="" rwaccess="RW"/>
    <bitfield id="RSVD1" width="1" begin="6" end="6" resetval="0x0" description="Reserved" range="" rwaccess="RW"/>
    <bitfield id="PLLENSRC" width="1" begin="5" end="5" resetval="0x1" description="PLLEN Mux Control Source 1 = PLLEN Mux is controlled by input pllen_pi. PLLCTL.PLLEN is don't care 0 = PLLEN Mux is controlled by PLLCTL.PLLEN. pllen_pi is don't care" range="" rwaccess="RW"/>
    <bitfield id="PLLDIS" width="1" begin="4" end="4" resetval="0xX" description="Asserts DISABLE to PLL if Supported 1 = PLL Controller output pll_disable_po = 1. 0 = PLL Controller output pll_disable_po = 0. Chip team must pay attention to the disable signal polarity of the PLL they use. Some PLLs may require PLLDIS=1 to disable PLL, some PLLs require PLLDIS=0 to disable PLL. Note that PLL Controller only supports one pll_disable_po output for both PLLA and PLLB. This is possible because the non-selected PLL is already placed in power down mode." range="" rwaccess="RW"/>
    <bitfield id="PLLRST" width="1" begin="3" end="3" resetval="0xX" description="Asserts RESET to PLL if Supported.Controls output pll_reset_po. 1= PLL Controller output pll_reset_po = 1. 0= PLL Controller output pll_reset_po=0. Chip team must pay attention to the reset signal polarity of the PLL they use. Some PLLs require PLLRST=1 to reset the PLL. Some PLLs require PLLRST=0 to reset the PLL. Note that PLL Controller only supports one pll_reset_po output for both PLLA and PLLB. This is possible because the non-selected PLL is already placed in power down mode." range="" rwaccess="RW"/>
    <bitfield id="RSVD" width="1" begin="2" end="2" resetval="0x0" description="Reserved" range="" rwaccess="RW"/>
    <bitfield id="PLLPWRDN" width="1" begin="1" end="1" resetval="0x1" description="Selects PLL Power Down for the PLL selected by PLLSELB.The PLL not selected by PLLSELB is NOT controlled by PLLPWRDN bit. The not-selected PLL will stay in power down regardless of PLLPWRDN value. 0 = Selected PLL Operational. If PLLSELB=0 (PLLA selected), PLL controller output pll_a_pwrdn_po is deasserted low. If PLLSELB=1 (PLLB selected), PLL controller output pll_b_pwrdn_po is deasserted low. 1 = Selected PLL Placed In Power Down State. If PLLSELB=0 (PLLA selected), PLL controller outputs pll_a_pwrdn_po is asserted high. If PLLSELB=1 (PLLB selected), pll_b_pwrdn_po is asserted" range="" rwaccess="RW"/>
    <bitfield id="PLLEN" width="1" begin="0" end="0" resetval="0x0" description="PLL Mode Enable This bit controls the multiplexer before the SYSCLK dividers D1 to Dn. 0 = Bypass Mode PreDiv, PLL, and PostDiv are bypassed. SYSCLK divided down directly from input reference clock refclk. 1 = PLL Mode PLL is used. SYSCLK divided down from PostDiv output" range="" rwaccess="RW"/>
  </register>
  <register id="PLLDIV1" acronym="PLLDIV1" offset="0x118" width="32" description="Return to the . PLL controller divider1 control register">
    <bitfield id="RSVD1" width="16" begin="31" end="16" resetval="0x0" description="Reserved" range="" rwaccess="RW"/>
    <bitfield id="DN_EN" width="1" begin="15" end="15" resetval="0xX" description="Divider Dn Enable 0 = Divider n Disabled. SYSCLKn is also gated before and after divider Dn. 1 = Divider n Enabled" range="" rwaccess="RW"/>
    <bitfield id="HALF_RATIO" width="1" begin="14" end="14" resetval="0x0" description="Ratio is in half steps.Example 1: if RATIO = 00000 and HALFRATIO=1 the divider will be /1.5. Example 2: RATIO=10111 and HALFRATIO=1 divider will be /24.5. Example 3: if RATIO=00011 and HALFRATIO=0 divider will be /4. THE HALF RATIO DIVIDER IS NOT A 50% DUTY CYCLE. It is a single 1x high clock pulse followed by low time until ratio is met. Note: To enable half step ratio dividers user must also set the associated bit in the PLLHDIVEN register PRIOR to writing the PLLDIVn register. If PLLHDIVEN register is not enabled then HALF_RATIO will not be writable. Changing the PLLHDIVEN register, set or clear, will not set or clear the HALF_RATIO bit in PLLDIVn register. This is to protect and enable backward compatible software in the chance it accidently wrote this bit field." range="" rwaccess="RW"/>
    <bitfield id="RSVD" width="6" begin="13" end="8" resetval="0x0" description="Reserved" range="" rwaccess="RW"/>
    <bitfield id="RATIO" width="8" begin="7" end="0" resetval="0xX" description="Divider Dn Ratio (SYSCLKn divider) 00000=/1 00001=/2 00010=/3 00011=/4 00100=/5 00101=/6 00110=/7 00111=/8 01000=/9 01001=/10 01010=/11 01011=/12 01100=/13 01101=/14 01110=/15 01111=/16 10000=/17 10001=/18 10010=/19 10011=/20 10100=/21 10101=/22 10110=/23 10111=/24 11000=/25 11001=/26 11010=/27 11011=/28 11100=/29 11101=/30 11110=/31 11111=/32 Note that the actual PLLDIVx divide ratio will not be modified when this field is written to. User must also set the GOSET bit so that the SYSCLKs selected in ALNCTL can change their RATIOs to the new values and remain phase-aligned. Note: see HALF_RATIO bit." range="" rwaccess="RW"/>
  </register>
  <register id="PLLDIV2" acronym="PLLDIV2" offset="0x11C" width="32" description="Return to the . PLL controller divider2 control register">
    <bitfield id="RSVD1" width="16" begin="31" end="16" resetval="0x0" description="Reserved" range="" rwaccess="RW"/>
    <bitfield id="DN_EN" width="1" begin="15" end="15" resetval="0xX" description="Divider Dn Enable 0 = Divider n Disabled. SYSCLKn is also gated before and after divider Dn. 1 = Divider n Enabled" range="" rwaccess="RW"/>
    <bitfield id="HALF_RATIO" width="1" begin="14" end="14" resetval="0x0" description="Ratio is in half steps.Example 1: if RATIO = 00000 and HALFRATIO=1 the divider will be /1.5. Example 2: RATIO=10111 and HALFRATIO=1 divider will be /24.5. Example 3: if RATIO=00011 and HALFRATIO=0 divider will be /4. THE HALF RATIO DIVIDER IS NOT A 50% DUTY CYCLE. It is a single 1x high clock pulse followed by low time until ratio is met. Note: To enable half step ratio dividers user must also set the associated bit in the PLLHDIVEN register PRIOR to writing the PLLDIVn register. If PLLHDIVEN register is not enabled then HALF_RATIO will not be writable. Changing the PLLHDIVEN register, set or clear, will not set or clear the HALF_RATIO bit in PLLDIVn register. This is to protect and enable backward compatible software in the chance it accidently wrote this bit field." range="" rwaccess="RW"/>
    <bitfield id="RSVD" width="6" begin="13" end="8" resetval="0x0" description="Reserved" range="" rwaccess="RW"/>
    <bitfield id="RATIO" width="8" begin="7" end="0" resetval="0xX" description="Divider Dn Ratio (SYSCLKn divider) 00000=/1 00001=/2 00010=/3 00011=/4 00100=/5 00101=/6 00110=/7 00111=/8 01000=/9 01001=/10 01010=/11 01011=/12 01100=/13 01101=/14 01110=/15 01111=/16 10000=/17 10001=/18 10010=/19 10011=/20 10100=/21 10101=/22 10110=/23 10111=/24 11000=/25 11001=/26 11010=/27 11011=/28 11100=/29 11101=/30 11110=/31 11111=/32 Note that the actual PLLDIVx divide ratio will not be modified when this field is written to. User must also set the GOSET bit so that the SYSCLKs selected in ALNCTL can change their RATIOs to the new values and remain phase-aligned. Note: see HALF_RATIO bit." range="" rwaccess="RW"/>
  </register>
  <register id="PLLCMD" acronym="PLLCMD" offset="0x138" width="32" description="Return to the . PLL Controller command register">
    <bitfield id="RSVD" width="30" begin="31" end="2" resetval="0x0" description="Reserved" range="" rwaccess="RW"/>
    <bitfield id="OSCPWRDN" width="1" begin="1" end="1" resetval="0x0" description="iOscillator Power Down Command 1: A write of 1 (doesn't need to be a transition from 0 to 1) to this bit initiates oscillator power down command. 0: A write of 0 to this bit clears the bit to zero but causes no effect. Read from this field returns the value previously written. Once written a 1, the bit remains a 1 unless if user writes a 0 to it. Do not read this bit for status of oscillator power down. In the case when CLKMODE = 1 (CLKIN mode), write to OSCPWRDN bit still occurs, but no oscillator power down command is actually sent because osc is already in power down. Read from this bit returns the value written." range="" rwaccess="RW"/>
    <bitfield id="GOSET" width="1" begin="0" end="0" resetval="0x0" description="GO bit for SYSCLKx phase alignment. GOSET = 1: A write of 1 to this bit signifies that the new divide ratios in PLLDIV[1:n] are taken into account at the nearest possible rising edge to phase align the clocks. The actual SYSCLKx to be aligned are selected in register ALNCTL. When divide-ratio change and clock alignment are completed, GOSET remains 1. Subsequent write of 1 to this register (even though the field was already a 1) causes the command for divide-ratio change and clock alignment. GOSET = 0: A write of 0 to this bit clears the bit to zero but causes no effect. Read from this field returns the value previously written. When writing consecutively to this field, the user must poll the GOSTAT between accesses to see if previous command for clock alignment and divide-ratio change has completed. Otherwise operation is undefined. Do not read GOSET in this command register for status." range="" rwaccess="RW"/>
  </register>
  <register id="PLLSTAT" acronym="PLLSTAT" offset="0x13C" width="32" description="Return to the . PLL Controller status register">
    <bitfield id="RSVD" width="29" begin="31" end="3" resetval="0x0" description="Reserved" range="" rwaccess="RW"/>
    <bitfield id="STABLE" width="1" begin="2" end="2" resetval="0xX" description="OSCIN Stable This bit shows the status of the rstclk_cnt_done_po signal. It indicates if the rstclk counter has finished counting, implying that the OSCIN/CLKIN is stable. The d_rstclk_cnt_pi must be set properly to allow rstclk counter to count sufficient amount of time for clock sources to become stable. 0 = rstclk counter not done counting, implying OSCIN/CLKIN input may not yet be stable. 1 = OSCIN/CLKIN is assumed to be stable. This bit is set to 1 if any one of the three cases is true: - rstclk counter has finished counting d_rstclk_cnt_pi number of rstclk cycles. - rstclk counter is paramterized out and does not exist, in which case OSCIN/CLKIN is assumed to be stable when por_pi_n is de-asserted." range="" rwaccess="R"/>
    <bitfield id="LOCK" width="1" begin="1" end="1" resetval="0x0" description="PLL Core STATUS This bit returns the lock status of the selected PLL core (if supported by PLL core). For example, if PLLSELB=0 (PLLA selected), it reflects the status of pll_a_lock_i. If PLLSELB-1 (PLLB selected), it reflects the status of pll_b_lock_i. 0 = PLL core not locked. The corresponding PLL Controller output pll_[x]_lock_out=0. (where [x] is a or b depending on PLLSELB). 1 = PLL core locked. The corresponding PLL Controller output pll_[x]_lock_out=1. (where [x] is a or b depending on PLLSELB). Note that not all PLL Core supports the lock signal. Check the PLL used to see if it has a functional lock output. Therefore this bit may not need to be documented to users." range="" rwaccess="R"/>
    <bitfield id="GOSET" width="1" begin="0" end="0" resetval="0x0" description="Reflects the status of GO transition.Read from this register returns the status of the GO operation. Writes to the register are ignored. GOSTAT = 1: This bit goes to 1 as soon as GOSET in PLLCMD is written to. It remains a 1 when GO operation (divide-ratio change and clock alignment) is in progress. This bit automatically clears to 0 when GO operation is completed. GOSTAT = 0: No GO operation in progress. Software note: Users must not initiate another GOSET operation in PLLCMD until GOSTAT is cleared to 0." range="" rwaccess="R"/>
  </register>
  <register id="ALNCTL" acronym="ALNCTL" offset="0x140" width="32" description="Return to the . PLL Controller clock align control register">
    <bitfield id="RSVD" width="16" begin="31" end="16" resetval="0x0" description="Reserved" range="" rwaccess="RW"/>
    <bitfield id="ALN" width="15" begin="15" end="1" resetval="0x1" description="SYSCLKx needs to be aligned with other clocks selected in this register. ALNx = 0: Do not need to align SYSCLKx to other clocks. SYSCLKx is left free-running. ALNx = 1: Align SYSCLKx to other clocks selected in this register Software note: This bit should only be modified when GOSTAT is 0. Software note: In the case when a divider is disabled (DxEN=0) but the respective ALNx=1, GO operation should ignore ALNx=1. DxEN takes priority. Existence of ALN[8:3] are determined by RTL parameter SYSCLK. If the corresponding SYSCLK does not exist, the ALNx bit will be read-only and default to 0." range="" rwaccess="RW"/>
    <bitfield id="ALN1" width="1" begin="0" end="0" resetval="0x1" description="SYSCLK1 needs to be aligned with other clocks selected in this register. ALN1 = 0: Do not need to align SYSCLK1 to other clocks. SYSCLK1 is left free-running. ALN1 = 1: Align SYSCLK1 to other clocks selected in this register Software note: This bit should only be modified when GOSTAT is 0. Software note: in the case when a divider is disabled (D1EN=0) but ALN1=1, GO operation should ignore ALN1=1. D1EN takes priority." range="" rwaccess="RW"/>
  </register>
  <register id="DCHANGE" acronym="DCHANGE" offset="0x144" width="32" description="Return to the . PLLDIV ratio change register">
    <bitfield id="RSVD" width="16" begin="31" end="16" resetval="0x0" description="Reserved" range="" rwaccess="RW"/>
    <bitfield id="SYS" width="15" begin="15" end="1" resetval="0x0" description="SYSCLKx divide ratio has been modified.SYSCLKx ratio will be changed during GO operation. SYSx = 0: SYSCLKx ratio has not been modified. When GOSET is set, SYSCLKx will not be affected. SYSx = 1: SYSCLKx ratio has been modified. When GOSET is set, SYSCLKx will change to the new ratio." range="" rwaccess="R"/>
    <bitfield id="SYS1" width="1" begin="0" end="0" resetval="0x0" description="SYSCLK1 divide ratio has been modified.SYSCLK1 ratio will be changed during GO operation. SYS1 = 0: SYSCLK1 ratio has not been modified. When GOSET is set, SYSCLK1 will not be affected. SYS1 = 1: SYSCLK1 ratio has been modified. When GOSET is set, SYSCLK1 will change to the new ratio." range="" rwaccess="R"/>
  </register>
</module>
